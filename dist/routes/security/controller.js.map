{"version":3,"sources":["../../../src/routes/security/controller.js"],"names":["initializer","app","Controller","jwt","services","secretKey","config","User","connection","models","bcrypt","user","sign","expiresIn","token","findOne","where","email","username","then","_user","compare","password","match","payload","name","module","exports"],"mappings":";;;;;;;;AAAA,SAASA,WAAT,CAAqBC,GAArB,EAA0B;AACzB,QAAO,IAAIC,UAAJ,CAAeD,GAAf,CAAP;AACA;;IAEKC,U;AACL,qBAAYD,GAAZ,EAAiB;AAAA;;AAChB,OAAKE,GAAL,GAAWF,IAAIG,QAAJ,CAAaD,GAAxB;AACA,OAAKE,SAAL,GAAiBJ,IAAIK,MAAJ,CAAWA,MAAX,CAAkBD,SAAnC;AACA,OAAKE,IAAL,GAAYN,IAAIO,UAAJ,CAAeC,MAAf,CAAsBF,IAAlC;AACA,OAAKG,MAAL,GAAcT,IAAIG,QAAJ,CAAaM,MAA3B;AACA;;;;;uFACWC,I;;;;;;;eAES,KAAKR,GAAL,CAASS,IAAT,CAAc,EAAED,UAAF,EAAd,EAAwB,KAAKN,SAA7B,EAAwC,EAAEQ,WAAW,IAAb,EAAxC,C;;;AAAdC,a;yCACCA,K;;;;;;;;;;;;;;;;;;;yFAESH,I;;;;;;;;0CAGR,KAAKJ,IAAL,CAAUQ,OAAV,CAAkB,EAAEC,OAAO,EAAEC,OAAON,KAAKO,QAAd,EAAT,EAAlB,EAAuDC,IAAvD;AAAA,6EAA4D,kBAAMC,KAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAE9DA,SAAS,IAFqD;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAG7C,MAAKV,MAAL,CAAYW,OAAZ,CAAoBV,KAAKW,QAAzB,EAAmCF,MAAME,QAAzC,CAH6C;;AAAA;AAG3DC,mBAH2D;AAI3DC,qBAJ2D,GAIjD;AACfC,qBAAML,MAAMK,IADG;AAEfP,yBAAUE,MAAMH;AAFD,eAJiD;;AAAA,mBAS7DM,KAT6D;AAAA;AAAA;AAAA;;AAAA,gDAUzDC,OAVyD;;AAAA;AAAA,gDAYzD,IAZyD;;AAAA;AAAA;AAAA;;AAAA;AAAA,gDAgB1D,IAhB0D;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,UAA5D;;AAAA;AAAA;AAAA;AAAA,Y;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BVE,OAAOC,OAAP,GAAiB3B,WAAjB","file":"controller.js","sourcesContent":["function initializer(app) {\n\treturn new Controller(app);\n}\n\nclass Controller {\n\tconstructor(app) {\n\t\tthis.jwt = app.services.jwt;\n\t\tthis.secretKey = app.config.config.secretKey;\n\t\tthis.User = app.connection.models.User;\n\t\tthis.bcrypt = app.services.bcrypt;\n\t}\n\tasync login(user) {\n\t\t// Use jwt to generate token based on valid user returned from database\n\t\tconst token = await this.jwt.sign({ user }, this.secretKey, { expiresIn: '1h' });\n\t\treturn token;\n\t}\n\tasync verifyUser(user) {\n\n\t\ttry {\n\t\t\treturn this.User.findOne({ where: { email: user.username } }).then(async _user => {\n\n\t\t\t\tif (_user != null) {\n\t\t\t\t\tconst match = await this.bcrypt.compare(user.password, _user.password);\n\t\t\t\t\tconst payload = {\n\t\t\t\t\t\tname: _user.name,\n\t\t\t\t\t\tusername: _user.email\n\t\t\t\t\t}\n\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn payload;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n}\n\n\n\nmodule.exports = initializer;"]}