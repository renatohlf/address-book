{"version":3,"sources":["../../../src/routes/security/controller.js"],"names":["security","app","jwt","services","infra","bcrypt","secretKey","config","post","req","res","username","get","password","fieldsValidation","validationErrors","status","send","hashedPassword","hashSync","user","validateUser","err","result","message","undefined","sign","expiresIn","token","json","callback","dbConnection","connection","UsersDao","getUser","release","dbUser","i","length","compareSync","assert","notEmpty","module","exports"],"mappings":"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","file":"controller.js","sourcesContent":["function security (app){\n\tconst jwt = app.services.jwt;\n\tconst infra = app.infra;\n\tconst bcrypt = app.services.bcrypt;\n\tconst secretKey = app.config.config.secretKey;\n\n\n\t// Login endpoint\n\tapp.post('/api/login', function (req, res) {\n\t\tlet username = req.get('username');\n\t\tlet password = req.get('password');\n\n\t\t// Validate if fields are empty, return error if assert true\n\t\tfieldsValidation(req, function (validationErrors) {\n\t\t\tif (validationErrors) {\n\t\t\t\tres.status(400).send(validationErrors);\n\t\t\t} else {\n\t\t\t\t// Use bcrypt to encript password to ensure security\n\t\t\t\tlet hashedPassword = bcrypt.hashSync(password, 8);\n\n\t\t\t\tconst user = {\n\t\t\t\t\tusername: username,\n\t\t\t\t\tpassword: hashedPassword\n\t\t\t\t};\n\n\t\t\t\t// Validate if user exists in database \n\t\t\t\tvalidateUser(username, password, function (err, result) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tres.status(err.status).send(err.message);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (result != undefined) {\n\t\t\t\t\t\t\t// Use jwt to generate token based on valid user returned from database\n\t\t\t\t\t\t\tjwt.sign({ user }, secretKey, { expiresIn: '1h' }, (err, token) => {\n\t\t\t\t\t\t\t\tres.json({\n\t\t\t\t\t\t\t\t\ttoken\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tres.status(404).send('User not found.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n\n\t});\n\n\n\t// Function to validate if user exists in database \n\tfunction validateUser(username, password, callback) {\n\t\tinfra.dbConnection.connection(function (err, connection) {\n\t\t\tlet UsersDao = new infra.UsersDao(connection);\n\n\t\t\t// Execute query using username to verify if user exists.\n\t\t\tUsersDao.getUser(username, function (err, result) {\n\t\t\t\tconnection.release();\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err, null);\n\t\t\t\t} else {\n\t\t\t\t\tlet dbUser;\n\t\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\t\tdbUser = result[i];\n\t\t\t\t\t}\n\t\t\t\t\tif (dbUser != undefined) {\n\t\t\t\t\t\t// Use bcrypt function to compare if password typed in login is equals to the hashed password stored in database\n\t\t\t\t\t\tif (bcrypt.compareSync(password, dbUser.password)) {\n\t\t\t\t\t\t\tcallback(null, dbUser);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback({ message: 'Invalid user', status: 404 });\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback({ message: 'Invalid user', status: 404 }, null);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t});\n\n\t\t});\n\n\n\t}\n\n\t// Function to validate if fields are empty, return error if assert true\n\tfunction fieldsValidation(req, callback) {\n\t\treq.assert('username', 'Username is required').notEmpty();\n\t\treq.assert('password', 'Password is required').notEmpty();\n\n\t\tcallback(req.validationErrors());\n\n\t}\n\n}\n\nmodule.exports = security;"]}